<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>模拟vue响应式系统</title>
</head>
<body>
  
</body>
<script>
  // 首先我们定义一个 cb 函数，这个函数用来模拟视图更新，调用它即代表更新视图，内部可以是一些更新视图的方法
  function cb (val) {
    /* 渲染视图 */
    console.log("视图更新啦～"+val);
  }
  /*然后我们定义一个 defineReactive ，这个方法通过 Object.defineProperty 来实现对对象的「响应式」化，
  入参是一个 obj（需要绑定的对象）、key（obj的某一个属性），val（具体的值）。经过 defineReactive 处理
  以后，我们的 obj 的 key 属性在「读」的时候会触发 reactiveGetter 方法，而在该属性被「写」的时候则会
  触发 reactiveSetter 方法。*/
  function defineReactive (obj, key, val) {
    Object.defineProperty (obj, key, {
      enumerable: true, /* 属性可枚举 */
      configurable: true, /* 属性可被修改或删除 */
      get: function reactiveGetter () {
        return val
      },
      set: function reactiveSetter (newVal) {
        if (newVal === val) return
        cb(newVal)
      } 
    })
  }
  /*当然这是不够的，我们需要在上面再封装一层 observer 。这个函数传入一个 value（需要「响应式」化的对象），
  通过遍历所有属性的方式对该对象的每一个属性都通过 defineReactive 处理。（注：实际上 observer 会进行
  递归调用，为了便于理解去掉了递归的过程）*/
  function observer (value) {
    if (!value || (typeof value !== 'object')) {
      return
    }
    Object.keys(value).forEach((key) => {
      defineReactive(value, key, value[key])
    })
  }
  /*最后，让我们用 observer 来封装一个 Vue 吧！

  在 Vue 的构造函数中，对 options 的 data 进行处理，这里的 data 想必大家很熟悉，就是平时我们在写 Vue 
  项目时组件中的 data 属性（实际上是一个函数，这里当作一个对象来简单处理）。*/
  class Vue {
    // vue构造类
    constructor (options) {
      this._data = options.data
      observer(this._data)
    }
  }
  /*这样我们只要 new 一个 Vue 对象，就会将 data 中的数据进行「响应式」化。如果我们对 data 
  的属性进行下面的操作，就会触发 cb 方法更新视图。*/
  let o = new Vue({
    data: {
      tet: 'i am text'
    }
  })
  o._data.tet = 'i am text'
  console.log(o)
</script>
</html>